Section1:Hi everyone, in this video we're going to learn the REST API definition. Let me remind you of what we discussed in a previous video. We agreed on definitions for an API and for a NAB. And we created the schema to explain this concept. If it's new to you, you can check the previous video. If you're already familiar with the schema, I have some controversial news for you. The good news is that the schema is good for an explanation of the public APIs from the end user or business perspective. And the bad news is that schema is way too simplified and misses a lot of important technical aspects. You won't be able to test anything based on it. In this and the next videos, we are going to fix this issue. All of this was related to the APIs in general. And a lot of information is still valuable, as the REST API is the API at the end. But these four letters add a lot of complexity. Let's start by checking the definition of the REST API. The most common explanation of the REST API is something like this. A web API that obeys the REST architectural constraints is informal described as REST VOL. Typically for API topics, the definition instead of providing answers leads to more questions. And before we start this long or even endless journey, I want to show you a couple of pictures of the REST APIs. Sometimes it's better to see something once than to hear about it thousand times. For example, the Spotify API is built based on simple REST principles. You can see the HTTP post request symbol here. And HTTP response body example in the JSON format. The Jura API is a good example of REST APIs. And again, the request is posed with headers, path parameters and JSON body. Last example, I want to show you is SwaggerPetStore. It is a very popular REST API. And we are going to use it as well for the basic tests. Actually, this is the API mentioned in our story. And again, you can see the HTTP post request with the body and the body is again in JSON format. REST APIs can be very different from what you see on the screen. But typically these kinds of APIs people call REST APIs. And if you need to test something similar to what you have seen, then welcome to the scores. And in the next video, we are going to learn what is REST and what REST architectural constraints are.

Section2: Hi everyone, in this video we are going to learn what is REST and its architectural constraints. Let's begin. REST stands for Representational State Transfer. It is a software architectural style that was created to guide the design and development of the architecture for the remotely distributed systems, which includes web APIs on the World Wide Web. Even this definition shows that information is related to the developers more than testers, but we will need to know some basic knowledge. The developers will need to dive much deeper as those will need to build APIs. What is relevant for RSTesters is to know that REST is a software architectural style for the development of the software products on the Internet, and the key rules of the REST architectural style are REST constraints. And there are six of them. Client server architecture, statelessness, casualty, use of a layered system using a uniform interface and support for code on demand. If the system or API is built according to this principles, it's classified as RESTful, and we need to get familiar with each of them to understand what the REST API is. Let's start with the client server architecture. The client server model is a distributed application structure between the providers over a source of service, called servers, and service registers, called clients, separating the user interface concerns from the data storage concerns. As usual, the definition is intense. Let's talk about it in a simple way. The providers over a source or service called servers. This means that there is a server, a powerful computer, which has some data, like as the Google Maps server, which stores data, maps, coffee shops, everything. They have the data, and there are other systems on the Internet web which need the data, called clients. And those clients are me and you, the end users. Not we as humans, but the applications like browsers or apps on our phones. Each time when you search for the coffee shop in the Google Maps app, the app sends the question to the request to the server because maps and coffee shops are stored there. That's why clients are server requesters. They need a service. In our case, find the closest coffee shop. And the server finds the answer to your requests and sends the coffee shop location back. Provides a resource or service to the client as in the definition. This is a very light explanation of the theory, but for now we are not going to dive deeper into details of which principle. We'll have a separate video about each of them further in the course. Let's move to the next architecture constraint. Statelessness A stateless communication in which no session information is retained by the receiver, usually a server. As usual, this definition sounds complex. Let's get back to our schema. Again, we have a client app. Let's say browser in phone. And we have the Google server which stores the Las Vegas map. Las imagine the scenario. You, the end user, need a Las Vegas map. So you open the browser and search for Las Vegas. The browser asks the servers for the map. The server reaches in the catalog and finds the map and provides the map to the browser. Then, let's say it is 2 a.m. in the morning and you realize you have nowhere to stay. You open the browser again and the browser sends the new question to the server. I need a place to slip. But the server is confused. The server is polite and asks the question, where are you? The client is confused as well. He thought the server is a friend. And tried to push on the server's feelings. And asked to recall that they talked yesterday. But the server is not a friend. The server is a rest server. It leads us back to the definition. No such information is retained by the receiver, usually a server. The server forgets everything in the second when it sends the answer to the question. It doesn't remember the client or the data they shared. The client has no choice but sends the appropriate question. As it is said in the definition, Relvanization data is sent to the receiver by the client in such a way that every packet of information transferred can be understood in isolation without contacts information from previous packets in the session. So, client specifies the location again. This one server understands because it has all information needed and sent the hotels in Las Vegas to the client. If client will send a request in not-resful format again, then a restful server will ignore it. Because if we got the client at the moment server sent the hotels to the client. So, stateless communication is a very simple independent question answer sequence. The client asks the question and the server answers it appropriately. The client will ask another question. The server will not remember the previous question answer scenario and will need to answer the new question independently. I think for now this one is clear. We'll talk about it in deep in the future. Let's move to the next principle. The K-Shabilite principle. On the World Wide Web, clients can cache responses. The responses must define themselves as either cacheable or non-cacheable to prevent clients from providing stale or inappropriate data in response to further requests. Let's move to the client server schema to explain this. Everything is usual. Clients, server, map, resource. The client sends a request to the server. Hi, I just moved to LA and I need a new map. The server finds the map in the database and sends it back to the client. Additionally, the server informs the client that the map is huge and if the client will ask about each time when a user opens the map, the user will need to write. And how long to write depends on the download speed on the client's site. This is related to the definition. Responses must themselves as either cacheable or non-cacheable. And server informs the client that the client can cache the data and the response is cacheable. This kind of data like site logus images and maps is the best candidate to be cached and stored on the client's site. The clients decide to store the map and what does it mean for you as the end user? Is that each time when you will open the Google Maps app on your phone? The app will not send any requests to the server. It will take a map from your phone because it will be saved there. That is why some applications take up so much space on your phone. And if you clear the cache, then you can see that everything loads much slower. Because if you deleted the map on your phone, now it needs to then load a new map from the server. Anyway, every time when you open the Google Map, the LA map is taken not from the Google server, but from your phone where it is saved. There is one issue with this flow. What is there will be a new coffee shop? Let's say someone opened a new coffee shop 200 meters from your house. The data about the coffee shop exists at the server database. And if the map is taken from the phone, you won't be able to see the new coffee shop because it is not there. The server has a lot of updates every day. Because of it, the client should implement a mechanism once at some period of time to check for the updates. Let's say once per day client will ask the server if there are some updates to the map. And if there are some updates, let's say a new coffee shop is opened. Then the client will download those and update the cache with the newest data. It's up to the client to decide how often he wants updates. So again, cacheability means that if you already asked about some data and saved it on the client side. Next time, when you open the app, the client will show data from the cache instead of asking the server. And it can be thousands of time faster. Just not forget to update the cache time after time. I think this constraint is clear now. Let's move to the next one. The layered system can strain. A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediarily along the way. It is straightforward but as usual, let's check the schema. And as usual, the client asks for a coffee shop in LA. I know that I could provide a different example than a coffee shop. But I like consistency. And you will see this example a lot of times in the future, might by the simple be patient. So our request goes to the server and we have no idea what happens next. In reality, the LA map can be stored in one server. And coffee shops, data, names, images and coordinates can live on a third server. And the server which we asked for the map will coffee shops on its site can ask those servers for the data. Then, once data is on its site, the server can process it and send back to ask the response, with the map and coffee shops on it. And the client has no idea about everything that happened on the server site. Exactly what is mentioned in the definition. A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way. We have two more constraints. Let's move on. The next constraint is code on demand. Servers can temporarily extend or customize the functionality of a client by transferring executable code. To be honest, I haven't found an example of it in Google API or other public APIs, so for now we are going to skip the detailed explanation. I will try to find something in the future and will create a separate video. In general, the server sends some code and some logic to the client site. And client executes the script, displays the valid data to the user or sends appropriate data to the server. Anyway, this constraint is optional and self-explained. Server will send some code which a brother or app will execute. Let's move to the last constraint. And the last one is a big one. The uniform interface. It simplifies and decouples the architecture which enables each part to evolve independently. And it has four additional constraints. But we are not going to learn those for now. In simple words, there are client and server two separate independent unrelated systems. And they need a link between them. And because of that, they have a uniform interface. In our case, it is an HFTP web layer with key verbs to work with resources on the server. And we are going to talk about it in details in one of the next videos. Let's summarize what we have learned in this video. First of all, we got familiar with the rest of the finish and we learned that rest sends for a representational state to answer. And that it is a software architectural style for web development. And the core of the rest is six architectural constraints. Client server architecture, statelessness, cacheability, use of a layer system using a uniform interface and support for code and demand. All six principles are important. And we will have a separate video for each of them in the future. But to be able to start testing the rest APIs, there are two constraints that are essential to know. The client server architecture and uniform interface. Because of us, we are going to dive deeper into what stands behind those principles. And we are going to talk about the client server architecture in the next video.


Section3: Hi everyone, in this video we are going to learn what is client server architecture and how it affects REST API testing. Let's begin. The formal definition sounds like this. The client server model is a distributed application structure between the providers of a resource or service called servers and server sequesters called clients. For us it's important that there are two independent components, a client and a server. We need to learn roles and characteristics of each of them separately and then learn how the communication happens. Let's start from the server side. And again, I like to start with definitions. A server is a piece of computer hardware or software that provides functionality for other programs or devices called clients. First of all, the server is the computer hardware. Every page and every app on the internet is stored somewhere on a remote server. A remote server is not so mystical after all, it's just a part of a remote-lilcated computer. So for example, Google Maps Server is a machine where maps and images of the entire planet leave. Most likely the entire planet is too much for one machine, but anyway you got the point. Google has a lot of powerful servers. If compared to your laptop, you have the same machine, but you need to store only thousands of images. Because of that, you have let's say 500 gigabytes of disk space in total, it is enough for you. And the server, as we said, stores way more information because of it. It can have let's say five hard drives within two terabyte each. And it is only one machine. Another difference is that your laptop has only one user. And the server can serve millions of users. Because all other characteristics like CPU, cores, amount, or RAM are very different. The server is like a laptop. It's just more powerful and reliable than standard personal computers. The machine runs 24 hours per day. For now, it is enough about the hardware. Let's check the server software. And again, on the software side, the server is not as different as you think it is. On your laptop you have an operating system, let's say Windows. It helps you to work in laptop show Windows.


Section4: Hi everyone, in this video we are going to learn what does HTTP request consist of. Let's begin. The request method is a complex structure and if we would want to learn everything about it, it will take a lot of time. But to be able to run some basic tests of REST API, we don't need to know everything. We need to know at least two things. What are the URL and its structure? And what is the request method? Let's start with a URL. As usual, we start from the definition. And as usual, there are a lot of fancy words. A uniform resource locator URL, colloquially termed as web address, is a reference to a web resource that specifies its location on a computer network and a mechanism for redriving it. Let's keep it simple. The key words here are the web resource and the web address. Let's start with the web address. When you hear the word address, you think about something like this. Under the stairs, four private drive, little winging, Surrey, England, Greybirdon. So if somebody wants to find you, they can go to the country, then region, then exactly your house and even locate you in the house in our case. The web address is exactly the same thing. When you type in the address bar, google.com, it is the address of the house or server. If it is more detailed like google.com, slash maps, slash place, Los Angeles, California, USA, it means that you are under the stairs locked and can go out so you can be found there. But to be able to test API, you will need to know a little more about the URL structure. Let's check it based on this Google Maps link. We will divide this into three parts. It is not exactly right, but for now it is detailed enough. We have the protocol, HDPS, the domain name, www.google.com, and the path, which means that Harry hides under the stairs. And we will start from the domain name. One more complex definition. Let's read it out loud as usual. A domain name identifies an network domain or an internet protocol resource, such as a personal computer used to access the internet or a server computer. In simple words, it is the IP, the internet protocol. And I hope everybody knows what it is, or at least has seen it. If not, the IP is these numbers. And again for now, we don't need to dive too deep into this and be very accurate. All that you need to know is that google.com. In reality is the IP address, and IP address is the address of your device, like the exact address on your home. Your private drive, little winging, sorry, England, Greybwritten. This www.google.com is for us humans. So we can remember it and write it into the address bar. The browsers and servers want the numbers, the IP, instead of the human words. In other words, when you type google.com, the browser finds the IP address instead of you, to simplify your life. It is the same as the phone book on your smartphone. How many phone numbers do you remember? Not much I believe. Instead, you type your friend's name and see the phone number on the screen. You remember the name, not the numbers. Exactly the same happens with the websites. You remember websites names, Facebook, Google. You don't even know that those are IP address. To summarize, the website name, the domain name, is the IP. And the IP is the numbers, which means the address, like the real address of your house. Let's check this schema. As usual, we have the client, the browser app in this case, and we have the server. This time we have the domain name of the server, www.google.com. And as we said before, it is the IP address with numbers. And in reality, it is the real address of the server, the location where it is at this moment. Another thing worth mentioning is that each physical device, when connected to the internet, hasn't addressed as well. What is missed in our diagram is how a domain name is transformed into the IP address numbers. First of all, it is important to remember that both client and the server need to be connected to the internet. Otherwise, they won't be able to communicate. So we will add small internet icons here to the client and the server as well. And we will need to add the cloud as well. The internet, the worldwide web. Because all the clients and all the servers live in a cloud and are connected to the cloud, as imagine the real user scenario. You type the domain name, google.com, into the address bar, and press search. Each time your browser sends the same question. Oh, deep thought, I want to tell you the answer. The answer to life, the universe, everything. And each time it provides exactly the same answer, 42. I decided that there should be at least one joke in this video. And it was a good one. Let's check what happens in reality. In reality, the browser asks the domain system, which also lives in the cloud. About the IP address for the domain name, which you entered in the browser bar. And the cloud provides the IP address to the browser. And the browser knows the exact IP of the server. It can send the HTTP request. But before this, we need to learn what the last part of the URL is. And it is the path. And as usual, we start from definition. The path refers to the exact location of a resource, page, file, or other asset. The path resides after the host name and is separated by slash forward slash. And it is hard to imagine or get what it means. And we said before, the domain name is the house's location. It shows on which straight it is located and which house you need. Like for private drive. But you have no idea what is there, a house, a stadium, a coffee shop, maybe. You don't know. And the path is the exact location, like under the stairs. And more, the path specifies exactly what you want. So it says there is a house and under the stairs, there is a LA map. That is what I need. And that is where it is. Welcome back to the scheme again. So you want to see what is stored on Google.com. You haven't specified the path, what happens in this case. The browser sends this message to the internet. And then when the server receives the message and the message is without the pass, everything depends on the server logic. But in our case, the server will find the home page. Many modern websites can rewrite URLs like the home page for simplicity and elegance. That is what happened in our case. In reality, you also specify the resource just again, it is hidden from you. And when a client will receive the home page, it will render it on your screen. Let's check what happens in the scenarios where you specify the pass. Everything looks nearly the same. The difference is that you have specified that you want a map and that is under the stairs. You have specified which file you want and its exact location. The server easily finds the map and sends it back. The client app, the browser, renders the map for you. And you see the LA map in your browser. Again, everything is on a very, very high level and not exactly accurate. But it is still a lot of information. We will dig deep into details later. For now, I just want you to see the whole picture of how the internet file transition works. So we have talked about the domain name, which is the web address. And we have talked about the resource, path to web pages, images, maps, whatever. But there is one thing which is at the start of the URL. Adverse bar hides it from us in browsers because users have no need to see it. The HTTP part, the protocol. There are two words in this definition which deserve additional attention. The protocol and the data. The data is clear for now. It can be any data like the web page, image, video, etc. But the protocol part is not that easy to explain. The protocol is a set. So we have talked about the domain name, which is the web address. And we have talked about the resource, path to web pages, images, maps, whatever. But there is one thing which is at the start of the URL. Adverse bar hides it from us in browsers because users have no need to see it. The HTTP part, the protocol. There are two words in this definition which deserve additional attention. The protocol and the data. The data is clear for now. It can be any data like the web page, image, video, etc. But the protocol part is not that easy to explain. The protocol is a set of rules on how this data should be transferred. Instead of technical terms, let's try to explain this base on the analogy. Very very old analogy. Let's migrate to the early 1900s. Age before the smartphones, internet and McDonald's. The story was old, but the problem is the same. The little girl wanted a map of a coffee shop in LA. Yes, I know that kids don't drink coffee. The map was for her mom. Anyway, the girl lives in England and the map company is in the US. They didn't have the internet those days. So, the little girl writes a letter to Mr. Google company. The letter is the request data in our case. In the letter, she asks for the resource, the map. And the only way to send the letter is to use the post office by the conversation with post lady is short. It ends up that you need to have a passport to be able to send the letter and money to buy a mark and pay for the post office services. The post office has a protocol with a lot of rules. It checks you the center, who are you, where you live if you have 18 years old, etc. Same about the address. Rules about how the letter should look and its weight. And if any of those rules are not supported, the letter won't be approved to send. It ends up that mom fills the envelope according to the rules and puts the mark on it and goes through the girl to the post office. The post office lady checks is everything is according to the protocol and sends the letter to Mr. Google. This is a nice little story from the early 1900s, but the current World Wide Web works similarly. Instead of the little girl's mom, we have a client app, the browser. And let's imagine that the client sends the same message to the web. I need a map of coffee shops in LA. Then the cloud, same as the post office lady in the 1900s. We'll ask the browser to answer where her mom is. And again, it is because the cloud has the protocols, the rules. The protocol declares how your web browser should communicate with the web server. Same as the post office in the 1900s, the rules are related to the client, the server, the data package, and the message format. The browser doesn't have a mom, so it needs to send an appropriate kind of message itself. It provides a lot of data in an appropriate format and sends it to the cloud again. The cloud checks the message and if it is valid, sends it to the server. The server process the request finds the map and sends the message back to the cloud. The server knows the HTTP rules and sends the valid HTTP response. And the client finally receives everything and can render the page, put a map there and show the coffee shops to you. That is how it works in the HTTP world. Unfortunately, we are not there yet. You can go drink a cup of coffee and we will continue. The good news is that we have finished with the URL. Now you know that path is the path to the data on the server, like a web page or other data. The domain name is the IP address of the server. And the HTTP is the rules of how data can be requested by the client and be returned by the server. But there are still a couple of steps we need to do to understand developers' comment. Let's go back and check the requested client sent. There was one thing which we didn't explain. The HTTP is the protocol with the rules and one of the rules is client request should have the request methods. And we see the client sent GAT. So what does it mean? Request method GAT. According to the definition, the HTTP defines methods to indicate the desired action to be performed on the identified resource. And it means exactly what it says. In our example, the server has the resource web page. And the client, the browser, sends a GAT method in the message, because we want to get a web page. Each time when you enter a website name into the address bar and press search, the browser sends the GAT method by default. You don't see this because most users don't need to know this details. Same as you don't see HTTP and double-double-double-you in the address bar. Let's check other methods and where those are used. As we already discussed, the GAT method redrives resources from the server. The post method creates data, the put method. Updates data. And the delete method deletes data. The methods are self-described. That is why those are called verbs sometimes. There are a lot of other methods like head options, but we are interested in this for for now. Let's talk about those with the examples. We talked about the home page as an example of the resource, but we can't explain the other methods with a home page example. Even if you want, you can't delete the Google home page. All you can do with it is view it. You can send only a GAT method. We are going to talk about the coffee shops again. It has been a while since we used this example. Here we go again. We are going to use the reviews of the coffee shops in Google Maps. The coffee shop in Google Maps is the resource, and your review itself is the resource as well. And as said, the resource is a very wide term. Let's say you have been to the coffee shop, and you didn't like the coffee. On your smartphone, you write a comment and click the post button. And your browser will stand for messages into a appropriate format for you. So your comment will be sent in a JSON format, and the method which will be used will be the post method, because you want to create a review. The resource and the server says the comment, so other people can view it. And you can as well. So you want to see if your comment is published and other people can see it. So you go back to the map and click on the reviews button. When you click on the button, the browser sends a request to the server, the server. The method is GAT, because you want to retry the reviews. And the resource path is like this with a review resource in the end. Also, the client app sends the place ID, because you want to see reviews of the particular coffee shop, not all reviews in the world. The server receives their request, looks for all reviews related to the place ID 42, and sends a response back. And you can see your review among the others. We are going to have a couple of separate videos about each of the methods. Because of this, we will keep put and delete for now. I think you already got the concept. If you want to change your review, the method would be put. And if you would want to delete your review, the method would be delete. And I'm going to put the method in the description.


Section5: Hi everyone. In this video, we are going to learn what does HTTP response consist of. Let's begin. The HTTP response is a complex structure. And if we would want to learn everything about it, it will take a lot of time. But to be able to run some basic tests of REST API, we don't need to know everything. As we discussed before, the clients request looks something like this. And the server response looks something like this. The clients request we have discussed in a previous video. And if we will look closely at the server response, we will find two key elements of HTTP response. The status code and the response body. Let's start from the response code. This time definition is long, so we will talk about separate sentences. The status code is the 3 digit integer. The first digit of the status code defines its class. Let's check our postman response again. As you see, there is a status value. And it equals 200. Okay. And it's set in the definition. The status code is the 3 digit integer. And we see 3 digit, 200. The second part of the definition says the first digit of the status code defines its class. And in our case, the first digit is 2. Let's check to which to the classes is related. And we have 5 classes of response codes. Informational, successful, redirection, client error, a server error. And again, we will have separate detailed videos about response codes. And a lot of videos of testing those. So we will check the 200 response code for now. It means it is successful. The request was successfully received, understood and accepted. Let's check a more detailed explanation. The definition says that response code consists of a numeric status code, such as 200. First part is a numeric status code 200. That is exactly what we got in postman. And the second part is an contextual reason phrase such as okay, and again exactly the same we got. There are a lot of response codes and we are going to have separate video about each of them. For now, let's check the description of the 200 okay response code. And we are interested in this line in a gator request. The response will contain an entity corresponding to the requested resource. It leads us to the second part of the response, the response body. Let's check the response in the postman one more time. As you see the body is present here and it is the HTML code of the page with LAMAP. Postman is not the browser because of it, it has trouble rendering the hybrid text documents. Let's check the browser instead. When we enter the same URL into the browser address bar, we see a different picture. We see the Google website with the Los Angeles map. We see some images of the places and a lot of other data. And if you will check the dev console, you can see how many requests for those resources were sent by the browser. And you can see the response code here. And the resource type, images and HTML are the same as we saw in the postman. The browser made a user-friendly representation of the data for you. And again, we skipped some important details for now. Like response cookies and response headers, as we skipped a lot of response codes. All of this will have separate long videos and exercises in the future. For this video, a general understanding of the response code and the response body is enough. And in the next video, we are going to summarize what we have learned about the HTTP request response flow. See you there! Thank you for watching. If you like coffee or coffee shop, leave a thumbs up. If not, thumbs down. See you in the next video.


Section6: Hello everyone. Today we are going to learn the basics of the Postman tool. Let's begin. If you open the Postman for the first time, you see something like this. The screen with a lot of buttons, controls, sidebars, drop downs, etc. It is intense and overwhelming for the newbie. If I told you what each element is responsible for, you wouldn't watch the video to the end. And you would quit the course and the rest API testing. Maybe even would stop a drink coffee for a while. Instead, this video will be short and sweet. We'll talk about requests, responses and the collection sidebar. And later in the course, we will learn more and more features. For example, in this video, we will skip the Params authorization and header step. But later in the course, each of this will have a separate video. In this tutorial, we are going to talk only about the basics. So you will be able to send the request, check the response and save your data. We'll go with baby steps. Even if the screen is minimized and only the request bar is selected, still it is overwhelming. Let's go from the left to the right. But before we do this, it doesn't make sense to learn the request structure in the Postman without the real request data. Because of this, let's start with the story. I believe the real life scenarios are the best for these tutorials. We have this kind of story. It has the image of the request, the image of the response and the CURL. Not the best story, but not the worst, believe me. And we are especially interested in the CURL. If you are new to API testing and do not know what it is, don't worry. You don't need to know this for now. You just need to know how to use CURL instead. And right now I will tell you about the feature which a lot of people ignore and struggle a lot with the rest API testing. The import feature in the Postman. It is not the easiest feature, so it can look complex for people who are new to API testing. Don't be scared and watch the video till the end. It will be simple, I promise. First of all, let's copy the CURL data. And what is important here is to select everything from the letter C to the last single quote. Copy it and let's go to the Postman. On the Postman screen, you need to find the import button. It is here and click on it. The import dialog will be opened as usual with a lot of tabs. In this dialog, you need to find a click on the row text tab. Then you will have the text filled where you can paste your CURL. Let's do it. Here we go and now we can click continue. And we have got an error. The error doesn't have a lot of details. A general error that's something wrong. And that is why a lot of people don't use this feature, but I did that in purpose. You know, in a lot of tutorials everything looks so easy and then when you try it on your own, nothing works. I don't want to show this kind of tutorial. Instead, I want to help to resolve the basic issues which can happen on your way. I didn't copy the CURL properly. I skipped the last quote. Let's do it accurately this time. I skipped all steps till the continue button. Now we have the quote at the end of the CURL. Let's check what happens when you click the continue button now. This time the request data is successfully imported. We can see the URL, the headers and the method. Now we can learn the basic controls of the postman. But before that, I want to show one more feature related to the CURL. Believe me, it will help you a lot in the future. The feature is to generate the CURL by yourself. If you will click here, on the code button. Then the CURL will be generated on the right side bar. Because a lot of project developers can share the CURL with you or ask you to share their request you send. And this is the one of the easiest ways to do it. That's it. Let's go to the basics now. Here is the cup of coffee for you. Let's have a coffee break for a second. And now on we will have coffee breaks each time when we're finished talking about big topics. Or after stressful situations. Like you wanted to learn the basics of the postman. But instead you need to Google what is CURL? The second is over. Let's go to the response now. Some things which you see on the screen, we had partially discussed in previous videos. Like request method and URL. Other things are still new for you. Like parameters or headers. When I promise one of the next videos will be related to those. But currently our purpose is to learn the basics of the postman tool. Because of that let's concentrate on the familiar stuff. The request method and the endpoint. Let's step by step discuss what we have here. First of all we have the request method drop down. If we click on it. We can see a lot of request methods available there. There are four, let's say the main methods. That post, put, and delete. These four you will meet much more often than the others. When we import the CURL the Gap method was selected in this drop down. So we won't change the method and we will leave it as it is. Let's move to the next line. And the next line is the address bar. It is the same as you have seen in the browser. So you can enter the URL here. And more to the websites, the API have endpoints. The endpoints are the same as the website address as we discussed in the previous video. You have the domain name and the protocol. And the path is mostly called the endpoint in the API world. So when somebody says the endpoint, they can refer to the entire URL or only to the last part, it depends on the context. Actually, that is all what we need to send the simple request for the postman. The method and the URL, they are much more complex APIs. With perhaps authorization, headers, body, cookies, etc. All of those are important, but to talk about those now will be too comprehensive and intense. We are going to have the separate meaningful videos about each of those in the future. For now, let's send our request. We click on the blue send button. And we see more buttons, drop downs and data. It means that the requests were sent and processed and we will see the response back. Let's check the response in the same manner we checked the request before, step by step. The main thing is the response status code. We have discussed those in the previous video. In our case, it is 200 okay and it means exactly the same. Okay, everything is fine. The response is successful. In reality, developers can return their response even if everything is not okay at all. But we will talk about it later. The second important thing is the response body. It is displayed in this area. This button's pre-d, row, review just changed the view of the data we received. As usual, we are going to have a separate video about JSON. And we are going to test a lot of different response bodies. For now, it is enough to know that the response code is displayed here and the response body is displayed here. The same as with the request, there are a lot of other parts of the response, like cookies, headers, response time or size. But again, all of them will be discussed in a separate video. The request and the response player is the most important part for a tester who is new in REST API testing. Mostly you will send requests, check responses and that's all. This happens because people are not familiar with a lot of cool features in the postman, like parameters, tests, runner, templates, scripts, console, etc. And in our course, we are going to get familiar with all of those step by step. For now, let's check the basic one, save your request. Just do not forget about small breaks. Stand up, look in the window and give some rest to your body and mind. And then back to the postman. If we will check the main screen again, we can see the orange circle on the request. It is the important one. It means that the request is not saved. Sometimes to send even a successful request can take a lot of time and effort. Let's click on the save button on the right side of the screen to save the request data. And another complex and a big screen is displayed. And you can see that the save button is disabled. The postman doesn't allow you to save request by itself. Him to create the collection and then save the request to the collection. And postman has created a default collection for us, new collection. To start, it can confuse, but in reality it is a simple rule. The collection is the same as a folder. And the request is the file. To be able to save the file, you need to select in which folder it will leave. Instead of selecting the default collection, let's create our own collection. Just click on the new collection button. And the new folder is displayed. We need to set a collection name. I will name it petstore as it is an addoma name of the API. Then we need to click on create button. For some reason, the postman team decided that we don't need to be informed that a collection is created. So, we can be confusing, but in reality it is created and the breadcrumbs showing that we are already inside the petstore folder. Now, when we are in the folder, we can say our first request. Just click on the save button. And again, it can confuse a bit for the first time. You are not informed if the request is saved. And where you can find it. For the new people, all of this can be annoying, but after a couple of days of using the postman you'll like it. It has its reasons why it is created this way. First of all, you can see that the orange circle is gone. It means that the request is saved. For example, if I will change anything in a request. Let's say change the one to two in the path. You can see that the orange circle is there again. It means that there are changes in the request. And if you will click on the save button, this time there won't be any pop-up. The orange circle will be gone. And you can see the tooltip. No new changes to save. It means that the request is saved. But where we can find it. In the left sidebar. And it is the last thing we are going to discuss today if we will expand the sidebar. The postman's screen will show more information and become even more intense. There are a lot of useful things in the left sidebar. And again, most of them are ignored by a lot of testers. The one which is in use by all of the testers I believe is the collection step. This is the one which is open now. You can see collections here, folders. And our folder is the bad store. And you can see the save request here. The collection tab in the left sidebar is the place where you can manage your requests and collections. You can create, view, edit and delete those here. And again, we will play with it more in the next videos. I think for now you can have the last cup of nice coffee. Today you have learned how to send the request with the postman. Where to check the response? And how to save the request and collection. That's one small step for you. One giant gleeve for the rest API. Because the new rest API tester is born today.


Section8:  Hello everyone, welcome to the video how to test the API for the first time. Let's begin. In a previous video we selected the test and techniques to use on our project. Explore your testing and checklist-based testing. Insert the first API checklist and we were informed that we wouldn't receive access to swagger this week. Let's start with exploratory testing today. According to the STGB glossary, the exploratory testing is an approach to testing whereby the testers in amgly design and execute tests based on their knowledge, exploration of the test item and the results of previous tests. You can get familiar with it more on the ISDGB website, but we will simplify this. By simplifying, I mean something similar but not exactly the same. In my opinion, explore testing of the API is the process when you design and execute tests based on theoretical knowledge of the API testing based on the knowledge of the project. When we say design and execute tests, it means that we are going to write test summaries into the Google sheet and inputs outputs, our test data, which we are going to store in the postman. The second item of the exploratory testing is based on the theoretical knowledge of API testing and we had a lot of long videos with chemists that explained the basics of the API testing theory and the last one. Based on the knowledge of the project, as we said, we are new to the project. We don't have any knowledge about it and the documentation is terrible. This conditions are pretty bad, but we are the experts. So let's try to test now. And we start by checking our documentation and it is the same old story as in the previous videos, screenshot of the request, screenshot of the response and the C URL. Let's check the screenshots. On the first screenshot, we can see the request details, the method, the endpoint. We can see that endpoint includes the path parameter, path ID and information about the parameter. Also, we can see the C URL of the request. It looks promising we can run a couple of tests. Let's check the next screenshot before we start. On the second screenshot, we can see the HTTP response documentation. We can see the response code and the response body, which were returned after the call, which is specified in the C URL. And we can see the documentation. Three response codes, 200, 400, 404, and the expected response body for the 200 response code. To be honest, the situation is okay. Could be better, but could be worse. We are the experts, it is easy for us. So from where do we start? When you test APIs, the first thing which you need to do is to send the request and receive the response. And we have the C URL in the story. We will be able to use it to send the first request. Let's copy the C URL. And use the postman import feature as we have done in previous videos. I will skip steps here because it takes a lot of time. Once the request is imported, you can check the request data on the postman screen. The method get and the URL is displayed in the address bar. That is all that we need to send the request. Let's click the send button and check what we receive in the response. And we got the response. The response code is 200. And we can see the response body with a lot of data. Let's compare it to the documentation on the image. And we can see that in the documentation the response code 200 is specified. And we got exactly the same in the postman 200 okay. But when we check the response body on the screenshot, we can see a small body over cat and the cat's name is Tom. And we got completely different data. What do you think about this? Have we found our first bug? But we haven't started testing yet. Now, I don't think that is a bug. We are the experts and we know a simple rule. If you want to get some specific data, you must create the data before the test. And we don't know how to set the data. It will be another obstacle on our path. At least we got the 200 response code. And we see the data structure looks like a valid one. We were able to send a valid request and receive a valid response. Let's say the request in the postman. And we have walked through Saveflow twice already. So I will skip it. And we have saved it in a very organized manner. We have the collection, PathStoreSwagger. It is the domain name of the service. We can see it in the URL. After that, we have the folder v2.path.pathID. This is our endpoint. Can be checked in the URL as well. Instead of the number 1, I put the path ID path parameter as was on the screenshots of the swagger. And then the name of the test case, the happy path. And I hope that all of you know what means the happy path test case. It's when you pass the test case and you're happy. Not exactly, but you got the point. Okay, what I really mean by the happy path is the positive test. Some people call it a smoke test or a functional test. So the test cases cover positive scenarios. Check if the main functionality of a feature works properly. Check a feature in a way it is intended to be used. Check if the feature meets the functional requirements. And we were able to partially run this test case. It is the time to create our checklist. And we will start with the checklist structure. The same as in the postman. We will have a domain name and the endpoint. And then two test cases. The happy path test and negative test case. Why do we need two test cases? On the projects where people do not invest in processes, documentation and releases almost every day. It is a good idea to start with at least two tests per endpoint. Mostly it will be enough. Mostly you won't be able to increase coverage because you won't have enough time. We will talk about this in the future videos. For now, let's finish with our two test cases. The dropped version of the happy path test case is already created in postman. Let's do the same for the negative test. But before that, let's do a small coffee break. Running the first happy path mostly takes a lot of time. After this, everything goes much faster. Let's run the negative test now. You can have the question. Who said that the negative test case is needed at all? We have bad requirements and the functionality is not learned yet. This is the bad work environment. Why do we try to test it? The answer to all those questions. I am the one who said this. I created the video and we need to do it in this way. It is a joke, of course. Come down. The real answer is that it depends from a lot of things. A project, functionality, people, team maturity, time and processes. And only you are the one who can say if you need 1000 test cases or only 2 test cases. Or no test cases at all. My recommendation is, no matter how bad the project is, how bad the accommodation is, you need to have at least 2 test cases. Positive, happy path and negative break the functionality. If you have those, it means you understand and list the basics of the endpoint. So what is the negative test case? The official definition says, negative testing, testing a component or system in a way for which it was not intended to be used. I just shared the definition. We need to learn this together. But if you will ask me, my definition of negative testing is, you know what to do. All we know is what to do. We are testers. We are the experts. We know how to break things. But let's check the documentation first. When we check the request screen, we can see that we have proper documentation of the path parameter at I.B. The one at the end of the URL. It says integer int64. And also you can see the red asterix. It means that the parameter is required. And now we really know what to do. Let's break it. We can send a text instead of a number. In this case, we get 404 and job performance exception error. We can send a large number. In this case, we get the 404 and job performance exception error as well. We can send a very large number. In this case, we get the same result as previous one. We can delete a path ID parameter. In this case, we get the 405 error. We can send the post method instead of get request. In this case, we get the 200 and no clear error. We can send even the SQL or JavaScript in the path. In this case, we get the 404 and job performance exception error. We create a lot of scenarios like this. And it looks like we know what to do when do negative testing. But let's ask ourselves the question. Do we really know what we are doing? What would experts do? What is the purpose of all of this? First of all, as we said before. For now, for the first iteration of the explorer testing, it is enough to save at least one negative test. We are testers and the tests make our job visible. Test cases are very important artifacts. Because of this, let's run and save only one negative test for now. But there is another question to answer. How do select only one negative scenario? What would expert do? My answer is that we need to predict user behavior and try the most common mistake the end user can make. Again, for now, you can't be sure. You don't know the project and you don't have proper documentation. So it is your choice. And my choice is that the user won't specify the pad ID. So I saved another get request. In the get slash v2 slash pad slash pad ID folder, negative test case. And one more thing which we need to do is to save the response. It will help us in the future and it will be our expert result. We need to expand the save response drop down on the right of the screen. And then select the save as example option. After that, we can see the response saved under the rest. So in the future, you'll be able to check what kind of response you got there. And I want to emphasize one thing. I show not how it should be. I show how I would do this. All of this is just recommendations. Postman is the tool and there are different ways to use it. For example, you could not save the get one more time. You could do two under the same request. Or your collections and folders structure can be different. Find your own way. What will work for you? There is one more thing I need to mention. I made a couple of mistakes in previous slides. First of all, I forgot to put .io in the collection name. I have fixed it. Second, I forgot to put .gat into the folder name. I have fixed it. And I forgot to save the example of the positive test case response. Again, I have fixed it. Let's check the results in the Google sheet. So, we have two test cases written in our checklist in Google sheet. And we have two test cases written in the postman. Is it enough? Can we go drink coffee and do nothing? As I said, for the first iteration of the exposure testing, it is enough to have two test cases. And the first iteration is over. Now it is time for the next iteration. We know what the happy path looks like. And we know the negative test as well. It is time to learn more about the endpoint. Let's read the documentation one more time. And we are going to do it in the next video.


Section9:  Hello everyone, welcome to the video Exploratory Testing of GAD endpoint without knowledge of the project. Let's begin. In a previous video, we selected the testing techniques to use on our project. Exploratory Testing and checklist-based testing. And started the first API checklist. We created two test cases in our checklist in Google Sheet. We did the same in the postman. One happy path test case and one negative test case. Now it is time for Exploratory Testing. Let's begin. And we will start by reading the documentation. When I test, I want to have some ideas behind that. Our first document is the screenshot of the request in the smager. What we can learn there? First of all, we can see that the request is very simple. We have a method, GAD, and we have only one requirement, pass parameter. We don't have query parameters, we don't have required headers, and we don't have authorization. It simplifies our work a lot. Let's start with the method. The specified method is GAD. So what is the positive test case for the method? It means that we sent what was expected, GAD. And I will add it to the happy path. So we will know what happy path checks this as well. What is the negative test case for the method? Should we send the not specified method like post? And the answer is simple. It depends. It depends on what you are testing and on which kind of project you work. And as discussed before, we don't have knowledge of the project. What can we do in this case? That's right. We are going to try it. And when we try it, we got 200 OK. And some strange response body. Let's save this to the post one as the negative post test case. So we will remember what happened. I created two more folders, positive and negative, and saved our post test case to the negative folder, and saved the response that we got. All of this will be useful when we are going to discuss what we learned with the team. Let's add this test to our checklist now. So we did the same structure in the checklist. We have the positive folder and negative folder. And the happy path has only the method check, and the negative folder has two test cases. And we are not going to check all the rest methods. We need to talk with the team about at least this scenario first. Let's move to the path parameter now. This one is more interesting because we have info that needs to be verified. First of all, it says that it is required. Second, it says that it is the int64 value. The first requirement is that the ID is required. And we are going to write two test cases, one positive and one negative. The positive test case again is included in the happy path. We have sent the ID, one, and the negative test case is already written as well. That is the one we selected for the first negative test case, when the path ID is not thinned. So the required requirement is covered. Let's move to the next requirement. We have the requirement that the path ID parameter should be int64. What does it mean? The int data type is a number. The range of numbers, it starts from minus a lot. And it ends with plus a lot. We don't have any other information about the limits, because of this we are going to add five tests. Even six tests. First of all, happy path is the most common valid value. We will send one and it is already written. After that, we will have min value, minus a lot, and the max value, plus a lot. And I will add zero. It is specific value, never a bad idea to check it. To the negative test cases, we will add two test cases. The first one is below the min valid value. The second one is above the max value. If I have missed something, let me know in the comments or questions. Let's run this test in that postman. The first test is to send the min value in the path ID parameter. And what do we see in the results? And we can see the valid response body. It says that the path is not found. As we discussed before, you need to create a path if you want a path in the response. We didn't create it, so we got a response that there is no path in the database. It looks fine. Let's say the request and the test result. Here is the positive folder. As min is the valid number. And now let's send the value below the min limit. And we can see that we receive different result. The response code is the same, but the response body is different. Number format exception. Which looks valid. We got the valid response for invalid request. Let's save it and do the rest of the tests. It looks like a lot of work, so let's do a small coffee break. And again, you can pause the video and send up. It is good for your back. Look at the window. It is good for your eyes. Care about yourself. ABI can wait one minute. Okay, let's go back to the scenario. And while you were drinking coffee, I finished the job. Now we have the test cases on the checklist. Happy path. Min, max, zero test cases in the positive folder. And empty below min above max in the negative folder. Isn't it cool? So what's next? To be honest, we already have pretty good coverage of the bad ID parameter. But I will add one more invalid test related to it. Make your willing to guess. The bad ID is int value. It means it accepts only numbers. We can put their path's names, for example, or special character. So I added two more test cases, the fifth and the sixth. Send a text instead of the valid number. And send the special characters. Let's check these in the postman. And what we play with it, we can see that behavior is different even per character. Here we received a 404 response code in the unknown error, null for URL. And here we got the HTML error and the 400 response code. Bad request. In this scenario, we received 400 response codes as well. But empty body. To be honest, it looks like the real bug. The IPI should accept anything but numbers. And if the user puts something except the number, error should be the same. For now, we won't log the bug. I will tell you later what we are going to do with our results. So we have written 10 test cases already. This is not bad. Not bad at all. And we haven't tested the response yet. Let's learn is documentation. And what we can see on the screen. First of all, we see the real response. The response code and the response body. And in the love part, we can see the documentation. The response codes and the response bodies for different scenarios. And we have a problem. So we wrote the happy path test case. And they were specified that we should receive 200 OK. But when we send it, we don't receive 200 OK. We receive 404 not found. And the error response body. And if you will compare it to the document, you can see that it is not what you expected. You expected something like what the manager shared with Tom. Or at least something like this, because the request is valid. And same as we discussed before, you can think that you found the bug, but in reality, it is not a bug. When we start this tutorial, I imagine that effective exploratory can be only if we have some knowledge of the project. And the main problem for testing this GAD endpoint is that we don't know how to set the test data. What I mean by this is you are testing GAD endpoint. The GAD method can redrive information. It shows you what is in the database. If you want to see Tom in the server response body, you need to create Tom in the database first. So we are limited, very limited in our testing. And nothing can be done now. We can only write this down and highlight it in the meeting with the manager. And we will do it in the end of the video. For now, let's start with the response code. And we can see 3 of them. 200 OK, 400 in valid ID, and 404 not found. Let's start from 200 OK. 200 OK will be added to our happy path, because that is what we expected. We send the valid request and the valid response code should be returned. And we can see that in the documentation it is 200. But I will mark the happy path as red and we'll write a comment. So we need to talk with the manager. That we need the data to be set up and not changed, or we need to learn how to set data on our own. Or they will hard code data. That we will send ID1 and the data will always be the same. Or we will learn how to set it dynamically. As the expert will prefer a second approach, dynamic data. We will discuss this in the future videos. Let's check the next response code. The second response code is for 100. It says it when the invalid ID is supplied. And I have a question about it. What does it mean by invalid ID? Text? Special characters? Above max? Or negative number? We don't know. There is no other choice than to run all our tests in postman, and not the response code we receive. Let's do it. So we send a text. As we discussed, it is invalid as the ID should be integer. And we got 404. Doesn't look right. Let's note it. And there we go. We wrote there 404 response code with the text in the valid test case. And we will need to discuss this in the future with the team. Let's write the rest of the test cases. And we have updated our checklist. The positive test cases are blocked with the issue. That we can't set test data. And we'll have to comment for it. And the negative test cases have different results. Most of them provide 404. One returns 405. And only one case returned 400. And because of it, we won't write any additional test cases for now. We will just update the character test case to send a percentage character. As it provides 400 response core, the one we needed. But in general, we will discuss our findings with the team. And we will talk about it later. Let's finish the test in first. For now, we were able to receive the 400 at least in one test case. It is already a small win. Let's move to the last response code, 404. First of all, we can see that we were able to receive the response several times. But that is not what we looked for. We will discuss this later. The scenario which we need here is the next. You send the valid request. Let's say ID is two. But a pad is not created in the database. Because of this, you receive a 404 response code. We don't have such a scenario in our checklist yet. And it's up to you where to put it. Positive or negative, that is the question. And yes, it definitely a big question to answer. And I will put it to the positive test cases. But again, it is up to you. You can show your idea in the comments or questions. Let's run it in the postman. And we got 200 okay. Is this a bug? What do you think? Should we log a de facto report? And my answer is no. We have discussed this several times. This test case is blocked for the same reason as the other positive test cases. We need to learn how to create valid data before execution. We need to know how to delete the pad. Anyway, we are done with the response codes. Let's check the response body. And I have bad news for you. All test cases related to the response body are blocked for exactly the same reason. We can't set up the valid or invalid test data. Because of this, I will do the next. In our checklist, we'll add a response body check to the happy past test cases. I expect to have more than one type of valid response body because of it, we'll add here as well. And I expect to set bad data in the database, so I will add it to the negative test cases. And we'll mark those as blocked, all of them. Additionally, I will write here the response body is saved to the postman and needs to be checked in all those scenarios. I think we did a great job. It is time to summarize the results. It looks like a lot of work, so let's do a small coffee break. And again, I will repeat myself a lot with this. You can pause the video and stand up. It is good for your back. Look at the window. It is good for your eyes. Care about yourself. ABI can wait one minute. Okay, let's go back to the APIs. The happy past test case is blocked. We can't set test data, so we can't receive the valid response code or body. The same is related to all positive test cases. If we want to receive some specific response code or some specific body, we need to set the test data and we can't do it right now. So valid test cases are blocked. If we talk about a valid response body test case, there is no reason to investigate it for now. When we will get access to the postman, we will be able to create a big checklist and we will do it in the next video. And if we talk about negative test cases, we just need to discuss all our results with the team, because it looks like there are a lot of issues. So what's next? First of all, you need to set a meeting with a product owner. Somebody who knows the project should go through your findings. And the site, what is the back, what is the improvement, and what will be left as it is. Also, you need to discuss your access to the product, as your testing is very limited for now. And once your access will be solved and you will have the answers to all your questions, you can run the next explore to your testing cycle. And after that, we will have a lot of work. Finalize the checklist, prioritize the test cases, create test suits, smoke, regression, and all of this will be done in the next videos.


Section10:  Hello everyone, welcome to the video how to automate post API tests with Postman. Let's begin. In this video I want to show you how to do a happy path test case for crude operations. Create, read, update and delete. And the corresponding method for those post, get, put and delete. And we are going to start from the post endpoint. As a usual, we will start from the user story. A bad user story. We don't have acceptance criteria, descriptions or any explanation at all. We have a list of the endpoint. And the Spagger link. Let's check it. A Spagger is a tool for API documentation. We should be able to find here all the information needed for at least a happy path test case. And we are going to test endpoints specified in the user story. Post, put, get and delete. It is logical to start from the post endpoint. As we need to know how to create data. When we expand the endpoint, we can see more documentation. The sample of the request body. That method is post and URL details. But in general, this information provides more questions than answers. We don't know if all parameters are acquired or if some of those are optional. We don't know if any of these fields have any backend logic. We don't know if we need to set some data as preconditions. So what do we do now? We know that we are the experts. And when the experts need to test something like this, the expert starts with manual exposure testing. Yes, manual. You can't automate if you can't write a manual test case. But don't worry, in this video, we'll skip a lot. So let's keep the exploratory testing and go to its results. We drank a lot of coffee and played a lot of food ball. We did a little bit of testing. As a result, we managed to send a valid request. You can see the data in the C URL. The valid ID, valid name and other parameters. And we are able to receive a valid response. You can see the data is in the response. The cat, Tom, is there in the response and all the data related to it. The spagger is a good tool, but we prefer postman. Let's copy the request data, the C URL, and paste it into the postman. And again, we are going to skip how we copy-paste the data. All that you need to know, we used in the import feature. So we used the import feature and were able to send the request and receive the response successfully. Let's save the data to the postman. And as usual, we will skip the steps. I have created another folder in our pet store collection called it crude and saved the post request here. What's next? To be able to automate the tests, we need to have the tests themselves. So let's write a couple of them. And we have a very simple checklist. The response code should be 200 OK. The response body structure is valid. And the response body data should be valid. Let's test these checks manually first. The first test gate is simple. We can see the response code is 200. If I was the easiest one, let's move to the second one. The response body structure is valid. We don't have the proper documentation. How can we test it? In this kind of situation, I recommend assuming that what you receive is what you expect. And then clarify with the responsible person. For now, we will assume that what is received in the response we see is valid data. It will be our expect result. And when we talk about the structure, it means Carly brackets, square brackets, arrays and elements. And the purpose of this is to catch the moment when the response body structure is changed. It can lead to different consequences for UI or integrated services. How can we test this manually? First of all, we need to save the current response. From today, it will be our expected result. The rule is simple. If we don't change what we sent in the request, then nothing should change in the response. Now, when it is saved, we can use it tomorrow in a week or in a month to check what we got previously and compare it. But how could we compare it? Manually, it is not an easy task. So we'll need a tool. And you know, I like very expensive tools like Google Sheets or Paint. This one is the nodepad. But advanced version nodepad plus plus. We need to paste the experiment result here. Now we need to send the request one more time. Just to change some values this time. This time, we will send ID2. And we won't send one of the elements, the photos array. And we can see that the response body is different. And we see different data. Let's compare it anyway. Carly the response body. And when we paste it into the nodepad plus plus, we used to compare feature. So we have the expected result is on the left. And the actual result is on the right. We can see that the IDs are not the same. But it is not what we are interested in. We are interested in the response body structure. And we can see the difference in the photo URL element. Of course, it is a simulation of the bug. But if the response body will be different, you will be able to catch it in this way. This is my way. Let me know if you have a more sufficient way in the comments or questions. So we tested two test cases. The response code is 200 OK. And the response body structure. The last one is about the valid data. And in this test case, we're going to check if the data will send in the request is the same as the data we received in the response. As you see, we sent ID1 and received ID1. We sent the name Tom and received the name Tom. And we need to check the entire response body like this. How can we check this? It is the same as we did in the previous test case. We copy base everything to the nodepad plus plus and compare. And we can see that everything is the same. Let's break it. This API has backend logic. If you send 0 as the ID, then you receive a huge number as the ID instead of the 0. Let's compare request and response one more time. And the size of the data doesn't match. We didn't know if it is valid behavior or a bug. But this will help you to get an automation. I just wanted to show you that even when we have only three test cases, testing the API manually is not an easy task. It is possible and we can continue to just manually. But to automate it, less simple stuff will help a lot. We have a very simple API. And to check these three task cases manually can take like a couple of minutes. But there are API monsters out there. The response can contain 100 plus fields. The API can be with complex logic and you need 100 plus test cases to test it. And this will make manual testing possible but struggling. And with Postman automation is easy. As I said, I'm the manual QA. I'm not an automation engineer. And this is the course for manual QAs. If you know programming language, great. If you don't know, even better. Just don't be intimidated by this video. This video is an introduction, not a tutorial. We will learn everything step by step in the following. Now I want to show you what kind of magic you'll be able to do after completing the course. This is the first step. It's not a tutorial. It's not a tutorial. It's not a tutorial. Without further ado, let's automate these three test cases. The first test case is the simple one. You just check if the response code is 200 okay. It is so simple that you may wonder why we need to automate it at all. You will see it in the future why. But the main reason it is very simple to automate. All we need to do is to go to the test step, here on the screen. And on the top you can see the snippets. One of them says code is 200. Click on it. That's all. Congratulations. You have originally your first test in the postman. I told you it will be easy. And now if you will send a request, valid request. You can see here that one test is run and it is successful because it is green. That's all. That's how postman automation works. It is cool, isn't it? Next, it is a very simple test, but it is a good idea to check if it works properly. So we need to force it to fail. We are the testers, aren't we? We know what to do and how to break things. In my case, I changed the ID value to the character. It led to the response code 500, the server error. And as you can see, the test is failed because it is red. So now we are sure everything is okay. The test case works. Let's fix our data. We are done with the response code. Let's move to the interesting stuff. The second test case, check the body structure. It will be the interesting one. So we need to check if the response body structure is the same. All these brackets, key value pairs and arrays from where to start. From the same place, we started the manual testing. We need the expected result. We have spun their request and we receive the response. This response, which we received today, will become our expected result. And in the future, we will compare our responses to the swan. So what we need to do to save it, but in a different manner. We need to go to the pre-request script tab in the postman. And there we need to find another snippet. Send a global variable. Click on it. It will create another script. It is not the test. This test case is not as easy as the first one with a response of 200 OK. The script will include two things, with variable key and variable value. And we need to set our data there. And again, I will skip a lot of work I have done. I set the name of the variable, expected result. And for the value, I use the current response body. As a set, we'll take it for the expected result. This is the first step. Now we need to go to the test step. The second step is to add this line of code. In simple words, it allows us to work with response body values. It provides a lot of power. And we will learn in deep later in the course how to use it. Also, you need to know is that from now, each time when we will receive a response, the response body will be saved in this JSON object, which renamed the response. And the third step is to compare what we wrote in the pre-request script with what we received in the response. Again, don't be scared. It is simpler than it looks. We have the test name. And then we check the response is the same as the expected result. Let's send the request. And we can see that two tests are run and both are green. As you see, writing the script is not easy. But then you do a lot of work with one click. I want to remind you how we tested this manually. We compared responses and expected results in the node++ with a lot of copy-baseding. And now we can do it with one click. Send the request and see the results. And I want to highlight this one more time for the newcomers. It might look like complex stuff. And it is a complex stuff. But this course is oriented towards the manual QAs who are totally new to API testing and to automation. So you are in the right place. In this video, I just show you the magic which you will be able to do once you finish the course. Let's continue. Before we move to the next test case, we need to fail the current test first. And we can do it in a very easy manner. As you see, we hard code the data here. We expect this response will be exactly like this. The ID1, the name DOM, and etc. So all we need to do to change anything in the body and the test case will fail. The best way is to change something which will change the response body structure. In our case, I deleted the tag. So in the response, there is an empty array. And you can see that test is failed. The reason is that we expected a tag object, ID1, name tag1, instead of receiving an empty array. And the test case failed. We can see one slash two. It is because we have two test cases. And if it will click on the test results tab. We can see which one failed. And we can start to investigate the reason why it failed. But we know the reason. Let's fix it. So both test cases are passed again. And just like this, we automated two test cases out of three. Let's move to the last test case. The response body data is valid. What I mean by that is the data we received in the response should be the same as the data we sent in the request. If we sent ID1, the ID1 should be returned in the response. And the same is related to all the properties. How can we check it? In 99% of cases, you need to compare it to property. You will need to create a separate test for each value. Request ID equals response ID. Request name equals response name. Request status equals response status, etc. That is the proper way to do things. But what we'll do in an lazy way. As you see the request body and the response body are exactly the same. And we are going to use this. We are already halfway through. We can reuse the script which we wrote in the previous test. The response body already has the property. The JSON response object. Now we need the same for the request body. So we add the script. What it does is it saves the request body into the request body JSON object. And then we compare the request data to the response data. As I said, we will talk about it later in the next videos. So I don't explain it too well here. Let's send the request now. When we send the request, we can see that all three test cases are passed. And the last step is to fail the test case with invalid data. Let's send the ID to, for example. And we see that two test cases are passed and one test case is failed. Now the second test case failed and the one which we needed to fail worked fine. So why is that? While we are thinking, let's do a small break. Send up and look around. Care about your body. It is not healthy to sit for hours and hours, drink some coffee or water, and then go back to the API world. We can see what exactly happened. We hard coded data. A second test case expected the ID value to be one. So whenever we send a different ID, the test case is failed. As I said, the way we wrote the second test case is not the best practice, but it is fine for now. We still need to break the third test case, which is passed now. And we will do it in exactly the same manner as we did manually. We will send ID zero. As you see, when we send zero, we receive not or zero in a response, and the two test cases are failed now. And we can see on the test screen the reasons. So we are done. We automated three simple post test cases. What's next? I want to discuss some topics. First of all, you can think. Why do we need to automate this if it didn't take much time manually? Yes, automatic the test case for the first time is time consuming. But once you manage to do it, you can reuse the script. For example, if it will need to test the put endpoint, we will just copy-based all our scripts, do small fixes, and that's all. More important. Yes, for one API and three test cases, it can look like this. But what if you need to run regression testing once a week? And you have not three, but 100 endpoints. And each endpoint has from three to 10 tests. This approach will help you a lot. Each time you need to click on button, so you will need to click send 100 times that is all your job. You don't need to use notepads, tools, compare data, and everything. Now of course we want to click send 100 times. Let me introduce you to the game changer. This little guy, the runner feature. This little guy is the game changer for the regression and other types of testing. Let's click on it. As usual, new complex screen. But we will talk about it in the separate video. What is important for now is that I added three more endpoints. Get put delete endpoints. And the same three tests in each of them. We need to drag and drop our collection to the runner. And when all endpoints will be there, we can start our run. Just click this button. And in one second we have the results. Old 12 test cases are passed. As you see four endpoints, post, get, put, and delete. And the same three test cases for each of them. Isn't that cool? As I said, the game changer. And manually, it would take 15 minutes. And with automation, it can take a couple of seconds. As you can run those every day, so it saves a lot of time. That is why automation is important even for manual QAs. And I want to highlight it one more time. I'm not the automation QA. I'm the manual QA. I haven't worked as an automation tester in any project. That is why these tutorials can have some issues for experience automation engineers. And they are not for them. These tutorials are for manual QAs who want to test the API sufficiently. If you are the manual QA, if you have no experience in API testing at all, if you have no experience in desktop automation, welcome to this journey. And welcome anywhere.

