 Hi everyone, in this video we are going to learn what is REST and its architectural constraints. Let's begin. REST stands for Representational State Transfer. 
It is a software architectural style that was created to guide the design and development of the architecture for the remotely distributed systems, which includes web APIs 
on the World Wide Web. Even this definition shows that information is related to the developers more than testers, but we will need to know some basic knowledge. 
The developers will need to dive much deeper as those will need to build APIs. What is relevant for RSTesters is to know that REST is a software architectural style for 
the development of the software products on the Internet, and the key rules of the REST architectural style are REST constraints. And there are six of them. 

Client server architecture, statelessness, casualty, use of a layered system using a uniform interface and support for code on demand. 

If the system or API is built according to this principles, it's classified as RESTful, and we need to get familiar with each of them to understand what the REST API is. 
Let's start with the client server architecture. The client server model is a distributed application structure between the providers over a source of service, called servers, and service registers, called clients, separating the user interface concerns from the data storage concerns. As usual, the definition is intense. Let's talk about it in a simple way. The providers over a source or service called servers. This means that there is a server, a powerful computer, which has some data, like as the Google Maps server, which stores data, maps, coffee shops, everything. They have the data, and there are other systems on the Internet web which need the data, called clients. And those clients are me and you, the end users. Not we as humans, but the applications like browsers or apps on our phones. Each time when you search for the coffee shop in the Google Maps app, the app sends the question to the request to the server because maps and coffee shops are stored there. That's why clients are server requesters. They need a service. In our case, find the closest coffee shop. And the server finds the answer to your requests and sends the coffee shop location back. 

Provides a resource or service to the client as in the definition. This is a very light explanation of the theory, but for now we are not going to dive deeper into details 
of which principle. We'll have a separate video about each of them further in the course. Let's move to the next architecture constraint. 

Statelessness A stateless communication in which no session information is retained by the receiver, usually a server. As usual, this definition sounds complex. Let's get back to our schema. Again, we have a client app. Let's say browser in phone. And we have the Google server which stores the Las Vegas map. Las imagine the scenario. You, the end user, need a Las Vegas map. So you open the browser and search for Las Vegas. The browser asks the servers for the map. The server reaches in the catalog and finds the map and provides the map to the browser. Then, let's say it is 2 a.m. in the morning and you realize you have nowhere to stay. You open the browser again and the browser sends the new question to the server. I need a place to slip. But the server is confused. The server is polite and asks the question, where are you? The client is confused as well. He thought the server is a friend. And tried to push on the server's feelings. And asked to recall that they talked yesterday. But the server is not a friend. The server is a rest server. It leads us back to the definition. No such information is retained by the receiver, usually a server. 

The server forgets everything in the second when it sends the answer to the question. It doesn't remember the client or the data they shared. The client has no choice but sends the appropriate question. As it is said in the definition, Relvanization data is sent to the receiver by the client in such a way that every packet of information transferred can be understood in isolation without contacts information from previous packets in the session. So, client specifies the location again. This one server understands because it has all information needed and sent the hotels in Las Vegas to the client. If client will send a request in not-resful format again, then a restful server will ignore it. Because if we got the client at the moment server sent the hotels to the client. So, stateless communication is a very simple independent question answer sequence. The client asks the question and the server answers it appropriately. The client will ask another question. The server will not remember the previous question answer scenario and will need to answer the new question independently. I think for now this one is clear. We'll talk about it in deep in the future. Let's move to the next principle. The K-Shabilite principle. On the World Wide Web, clients can cache responses. The responses must define themselves as either cacheable or non-cacheable to prevent clients from providing stale or inappropriate data in response to further requests. Let's move to the client server schema to explain this. Everything is usual. Clients, server, map, resource. The client sends a request to the server. Hi, I just moved to LA and I need a new map. The server finds the map in the database and sends it back to the client. Additionally, the server informs the client that the map is huge and if the client will ask about each time when a user opens the map, the user will need to write. And how long to write depends on the download speed on the client's site. This is related to the definition. Responses must themselves as either cacheable or non-cacheable. And server informs the client that the client can cache the data and the response is cacheable. This kind of data like site logus images and maps is the best candidate to be cached and stored on the client's site. The clients decide to store the map and what does it mean for you as the end user? Is that each time when you will open the Google Maps app on your phone? The app will not send any requests to the server. It will take a map from your phone because it will be saved there. That is why some applications take up so much space on your phone. And if you clear the cache, then you can see that everything loads much slower. Because if you deleted the map on your phone, now it needs to then load a new map from the server. Anyway, every time when you open the Google Map, the LA map is taken not from the Google server, but from your phone where it is saved. There is one issue with this flow. What is there will be a new coffee shop? Let's say someone opened a new coffee shop 200 meters from your house. The data about the coffee shop exists at the server database. And if the map is taken from the phone, you won't be able to see the new coffee shop because it is not there. The server has a lot of updates every day. Because of it, the client should implement a mechanism once at some period of time to check for the updates. Let's say once per day client will ask the server if there are some updates to the map. And if there are some updates, let's say a new coffee shop is opened. Then the client will download those and update the cache with the newest data. It's up to the client to decide how often he wants updates. So again, cacheability means that if you already asked about some data and saved it on the client side. Next time, when you open the app, the client will show data from the cache instead of asking the server. And it can be thousands of time faster. Just not forget to update the cache time after time. I think this constraint is clear now. Let's move to the next one. The layered system can strain. A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediarily along the way. It is straightforward but as usual, let's check the schema. And as usual, the client asks for a coffee shop in LA. I know that I could provide a different example than a coffee shop. But I like consistency. And you will see this example a lot of times in the future, might by the simple be patient. So our request goes to the server and we have no idea what happens next. In reality, the LA map can be stored in one server. And coffee shops, data, names, images and coordinates can live on a third server. And the server which we asked for the map will coffee shops on its site can ask those servers for the data. Then, once data is on its site, the server can process it and send back to ask the response, with the map and coffee shops on it. And the client has no idea about everything that happened on the server site. Exactly what is mentioned in the definition. A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way. We have two more constraints. Let's move on. The next constraint is code on demand. Servers can temporarily extend or customize the functionality of a client by transferring executable code. To be honest, I haven't found an example of it in Google API or other public APIs, so for now we are going to skip the detailed explanation. I will try to find something in the future and will create a separate video. In general, the server sends some code and some logic to the client site. And client executes the script, displays the valid data to the user or sends appropriate data to the server. Anyway, this constraint is optional and self-explained. Server will send some code which a brother or app will execute. Let's move to the last constraint. And the last one is a big one. The uniform interface. It simplifies and decouples the architecture which enables each part to evolve independently. And it has four additional constraints. But we are not going to learn those for now. In simple words, there are client and server two separate independent unrelated systems. And they need a link between them. And because of that, they have a uniform interface. In our case, it is an HFTP web layer with key verbs to work with resources on the server. And we are going to talk about it in details in one of the next videos. Let's summarize what we have learned in this video. First of all, we got familiar with the rest of the finish and we learned that rest sends for a representational state to answer. And that it is a software architectural style for web development. And the core of the rest is six architectural constraints. Client server architecture, statelessness, cacheability, use of a layer system using a uniform interface and support for code and demand. All six principles are important. And we will have a separate video for each of them in the future. But to be able to start testing the rest APIs, there are two constraints that are essential to know. The client server architecture and uniform interface. Because of us, we are going to dive deeper into what stands behind those principles. And we are going to talk about the client server architecture in the next video.